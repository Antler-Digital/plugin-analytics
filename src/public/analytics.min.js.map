{
  "version": 3,
  "sources": ["../scripts/analytics-client.ts"],
  "sourcesContent": ["/* eslint-disable @typescript-eslint/require-await */\ninterface AnalyticsOptions {\n  domain?: string\n  endpoint?: string\n}\n\nclass Analytics {\n  private domain: string\n  private endpoint: string\n  // Debounce route change handling\n  private handleRouteChange = this.debounce(async () => {\n    await this.trackPageView()\n  }, 1000)\n  private initialized: boolean = false\n  private isTracking: boolean = false\n\n  private sessionStartTime: number\n\n  constructor(options: AnalyticsOptions = {}) {\n    // Default endpoint based on script src or fallback to /api/events\n    const scriptEl = document?.querySelector('script[src*=\"analytics.min.js\"]') as HTMLScriptElement\n    const defaultEndpoint = scriptEl?.src.replace('analytics.min.js', 'api/events')\n\n    this.endpoint = options.endpoint || defaultEndpoint || '/api/events'\n    this.domain = options.domain || window.location.hostname\n    this.sessionStartTime = Date.now()\n    void this.init()\n  }\n\n  // Add debounce utility\n  private debounce(fn: (...args: any[]) => void, delay: number) {\n    let timeoutId: NodeJS.Timeout\n    return (...args: any[]) => {\n      clearTimeout(timeoutId)\n      timeoutId = setTimeout(() => fn(...args), delay)\n    }\n  }\n\n  private getUtmParams(): Record<string, string> {\n    const urlParams = new URLSearchParams(window.location.search)\n    const utmParams: Record<string, string> = {}\n    ;['source', 'medium', 'campaign', 'term', 'content'].forEach((param) => {\n      const value = urlParams.get(`utm_${param}`)\n      if (value) {\n        utmParams[param] = value\n      }\n    })\n\n    return utmParams\n  }\n\n  private async init(): Promise<void> {\n    if (this.initialized) {\n      return\n    }\n\n    // Track initial pageview after a small delay to ensure page is fully loaded\n    setTimeout(() => this.trackPageView(), 100)\n\n    // Setup session end tracking\n    this.setupSessionEndTracking()\n\n    // Handle route changes for SPAs and regular navigation\n    window.addEventListener('popstate', this.handleRouteChange)\n\n    // For modern browsers, detect URL changes with debounced observer\n    let lastUrl = window.location.href\n    const observer = new MutationObserver(\n      this.debounce(() => {\n        const currentUrl = window.location.href\n        if (currentUrl !== lastUrl) {\n          lastUrl = currentUrl\n          this.handleRouteChange()\n        }\n      }, 1000),\n    )\n\n    // Only observe body and limit to specific changes\n    const body = document?.querySelector('body')\n    if (body) {\n      observer.observe(body, {\n        attributes: false,\n        characterData: false,\n        childList: true,\n        subtree: true,\n      })\n    }\n\n    this.initialized = true\n  }\n\n  private async loadPixel(url: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const pixel = new Image()\n      pixel.onload = () => {\n        pixel.remove()\n        resolve()\n      }\n      pixel.onerror = (error) => {\n        pixel.remove()\n        if (error instanceof ErrorEvent) {\n          reject(new Error(`Network error: ${error.message}`))\n        } else {\n          reject(new Error('Failed to load tracking pixel'))\n        }\n      }\n      pixel.src = url\n      pixel.style.display = 'none'\n      document?.body.appendChild(pixel)\n    })\n  }\n\n  // Helper method for exponential backoff retry\n  private async retryWithBackoff(\n    fn: () => Promise<void>,\n    maxAttempts = 3,\n    baseDelay = 1000,\n  ): Promise<void> {\n    for (let attempt = 0; attempt < maxAttempts; attempt++) {\n      try {\n        await fn()\n        return\n      } catch (error) {\n        if (attempt === maxAttempts - 1) {\n          throw error\n        }\n        const delay = baseDelay * Math.pow(2, attempt)\n        await new Promise((resolve) => setTimeout(resolve, delay))\n      }\n    }\n  }\n\n  private setupSessionEndTracking(): void {\n    // Track tab/window close\n    window.addEventListener('beforeunload', () => {\n      void this.trackSessionEnd()\n    })\n\n    // Track when user switches tabs\n    document?.addEventListener('visibilitychange', () => {\n      if (document?.visibilityState === 'hidden') {\n        void this.trackSessionEnd()\n      }\n    })\n\n    // Backup: track when user becomes inactive\n    let inactivityTimeout: NodeJS.Timeout\n    const resetInactivityTimeout = () => {\n      clearTimeout(inactivityTimeout)\n      inactivityTimeout = setTimeout(\n        () => {\n          void this.trackSessionEnd()\n        },\n        30 * 60 * 1000,\n      ) // 30 minutes of inactivity\n    }\n\n    // Reset timeout on user activity\n    ;['mousedown', 'keydown', 'touchstart', 'scroll'].forEach((event) => {\n      window.addEventListener(event, resetInactivityTimeout, { passive: true })\n    })\n\n    resetInactivityTimeout()\n  }\n\n  private shouldRetry(error: unknown): boolean {\n    // Improve error type checking\n    if (error instanceof Error) {\n      // Retry on network errors\n      if (error.message.includes('Network error')) {\n        return true\n      }\n    }\n    // Don't retry on other types of errors\n    return false\n  }\n\n  private async trackPageView(): Promise<void> {\n    // Add a guard to prevent tracking if the previous request hasn't completed\n    if (this.isTracking) {\n      return\n    }\n    this.isTracking = true\n\n    try {\n      await this.retryWithBackoff(async () => {\n        const eventsUrl = new URL(this.endpoint)\n        eventsUrl.searchParams.append('domain', this.domain)\n        eventsUrl.searchParams.append('path', window.location.pathname)\n\n        // Only add referrer if it's from a different domain\n        const referrer = document?.referrer\n        if (referrer && !referrer.includes(window.location.hostname)) {\n          eventsUrl.searchParams.append('ref', referrer)\n        }\n\n        // Add UTM parameters if they exist\n        const utmParams = this.getUtmParams()\n        Object.entries(utmParams).forEach(([key, value]) => {\n          eventsUrl.searchParams.append(`utm_${key}`, value)\n        })\n\n        await this.loadPixel(eventsUrl.toString())\n      })\n    } catch (error) {\n      // Only log if it's a final failure after retries\n      console.warn('Failed to track page view after retries:', error)\n    } finally {\n      this.isTracking = false\n    }\n  }\n\n  private async trackSessionEnd(): Promise<void> {\n    try {\n      const sessionDuration = Date.now() - this.sessionStartTime\n\n      // Use sendBeacon for more reliable delivery during page unload\n      const eventsUrl = new URL(this.endpoint)\n      eventsUrl.searchParams.append('domain', this.domain)\n      eventsUrl.searchParams.append('event', 'session_end')\n      eventsUrl.searchParams.append('duration', sessionDuration.toString())\n\n      // Fallback to sync image request\n      await this.loadPixel(eventsUrl.toString())\n    } catch (error) {\n      console.warn('Failed to track session end:', error)\n      // Optionally implement retry logic here\n    }\n  }\n\n  // Public method to manually track page views\n  public async trackView(): Promise<void> {\n    try {\n      await this.retryWithBackoff(() => this.trackPageView())\n    } catch (error) {\n      console.warn('Manual page view tracking failed after retries:', error)\n    }\n  }\n}\n\n// Create instance immediately\nconst analytics = new Analytics()\n\n// Export for advanced usage\nif (typeof window !== 'undefined') {\n  ;(window as any).Analytics = Analytics\n  ;(window as any).analytics = analytics\n}\n"],
  "mappings": "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",
  "names": ["Analytics", "options", "__publicField", "__async", "scriptEl", "defaultEndpoint", "fn", "delay", "timeoutId", "args", "urlParams", "utmParams", "param", "value", "lastUrl", "observer", "currentUrl", "body", "url", "resolve", "reject", "pixel", "error", "maxAttempts", "baseDelay", "attempt", "inactivityTimeout", "resetInactivityTimeout", "event", "eventsUrl", "referrer", "key", "sessionDuration", "analytics"]
}
